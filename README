Due date: Sunday 2/28/2016 @ 11:59pm

- Please remember to answer the questions in REPORT.txt

Assignment:
~~~~~~~~~~~

(1) Answer the questions in REPORT.txt

(2) Implement a PPC64 / Linux emulator (replaces qemu-ppc64)

Limitations:
~~~~~~~~~~~~

You don't have to support the full instruction set. Only:

- The subset generated by your p5 compiler + my ppc.asm

- Only two system calls: exit and write

- only 64 bit instructions

- always in big-endian mode

- always running in user mode

- Feel free to ignore the overflow and summary overflow bits in CR and XER
  unless your code uses them

Code structure:
~~~~~~~~~~~~~~~

There are two parts to this assignment:

- The compiler (fun2ppc) lives in src/fun2ppc. You can copy your solution
  for p5 there

- The emulator (emulator) lives in src/emulator

The emulator has 3 major parts:

- A memory model (memory.c / memory.h)

- An executable file loader (loader.c / loader.h)

- The processor state and instruction set emulator (state.c / state.h)

The system call interface
~~~~~~~~~~~~~~~~~~~~~~~~~

You will be emulating the PPC64 ISA as well the Linux system call
interface. Fortunately, our programs use two simple ones (write and exit)

The ppc64-linux system call interface is as follows:

- R0 contains the system call number (1 => exit, 4 => write)
- R3, R4, R5, ... contain the system call arguments
- The SC instruction is used to issue the system call. You need
  trap that and perform the system call logic in your emulator

Files
~~~~~

src/fun2ppc/*.[ch]     The compiler source (copy from p5)
src/emulator/*.[ch]    The emulator (to be completed by you)

fun2ppc        The compiler executable (generated by "make fun2ppc")
emulator       The emulator executable (generated by "make emulator")

For each test "tx"

tx.fun    the source program
tx.S      the equivalent x86-64 assembly program (generated by p5)
tx        the compiled program (generated by the Makefile)
tx.out    output produced by running tx
tx.ok     the expected output
tx.diff   the difference between tx.out tx.ok

Make targets:
~~~~~~~~~~~~~

make           # compile the compiler
make tx.S      # run the compiler on tx.fun and produce the x86-64 assembly
make tx        # run the compiler on tx.fun and produce the x86-64 executable
make tx.out    # run the compiled program and produce its output
make tx.diff   # produce the difference between tx.out and tx.ok
make tx.result # produce a summary of the result of running tx

make progs     # compile all the tests
make outs      # produce all the out files
make diffs     # produce all the diff files
make test      # produce summary output for all tests

Files to leave alone
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   t?.fun
   t?.ok

You can also add your own tests by creating a pair of
files (for example mytest.fun and mytest.ok)

To debug the emulator
~~~~~~~~~~~~~~~~~~~~~

You can use gdb to debug the emulator itself. For example:

    $ make emulator
    $ make t0
    $ gdb ./emulator
    gdb) run t0

But unlike qemu-ppc, you can't attach to it to debug the PPC64 program
unless you implement the GDB protocol in your emulator. Your best tool
is to set breakpoints in the emulator and look at variables or to 
user printf

It's not a bad idea to define functions that dump the PPC64 state when
needed.

